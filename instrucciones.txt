Cuando hay muchos tests y archivos de tests, surgen nuevas preguntas. ¿Cómo agrupar los tests?
¿Cómo ejecutar todos los tests de un directorio? Si hay muchos y son largos, 
¿se pueden ejecutar en paralelo?

Para resolver estas preguntas, se utilizan frameworks de testing especiales. 
Ayudan a organizar la estructura de los tests y proporcionan muchas características útiles, 
como una salida conveniente. Con la mayoría de estas características nos familiarizaremos más 
adelante en el curso. En el mundo de JavaScript, el framework más popular es Jest, desarrollado 
por Facebook. Por cierto, lo usamos para probar todas las prácticas en Códica.

A continuación se muestra una guía en la que crearemos un proyecto npm desde cero y agregaremos 
tests.

Configuración y ejecución
Crea un directorio llamado códica-jest en cualquier lugar de su computadora. Ingresa a él 
y ejecuta el siguiente comando:

npm init
Responde todas las preguntas del script de inicialización del proyecto. 
Asegúrate de que se haya creado el archivo package.json en la raíz del proyecto.

Ahora agreguemos un poco de código fuente. Crea un archivo src/index.js con el siguiente contenido:

// Esta función invierte la cadena pasada
export default str => str.split('').reverse().join('');
Jest es un paquete npm normal que se conecta localmente al proyecto en desarrollo. 
Jest solo se necesita durante el desarrollo, por lo que es mejor instalarlo en la sección 
devDependencies:

# En el directorio del proyecto
npm i --save-dev jest
Para que Jest funcione correctamente con el sistema de módulos, agrega la siguiente opción a 
package.json:

  "type": "module"
Jest espera que los tests se encuentren en el directorio __tests__, que generalmente se coloca 
en la raíz del proyecto. Dentro de este directorio, puede crear cualquier estructura, 
Jest encontrará todos los tests que se encuentren allí. La nomenclatura de los archivos de 
tests debe ser así: <name>.test.js. Donde <name>, por lo general, corresponde al nombre del 
módulo que se está probando.

Escribamos nuestro primer test. Crea un archivo __tests__/index.test.js con el siguiente 
contenido:

import reverse from '../src/index.js';

test('reverse', () => {
  expect(reverse('hello')).toEqual('olleh');
  expect(reverse('')).toEqual('');
});
Luego analizaremos la estructura de este archivo, pero por ahora intentemos ejecutar el test:

# Jest admite módulos ECMAScript en modo experimental
# Para habilitar el soporte de módulos en los tests,
# los tests deben ejecutarse con la variable de entorno NODE_OPTIONS
NODE_OPTIONS=--experimental-vm-modules npx jest
 PASS  __tests__/index.test.js
  ✓ reverse (11ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        1.166s
Ran all test suites.
¡Hurra! Los tests pasaron exitosamente.

Estructura
Echemos otro vistazo al archivo de test:

import reverse from '../src/index.js';

test('reverse', () => {
  expect(reverse('hello')).toEqual('olleh');
  expect(reverse('')).toEqual('');
});
Jest proporciona dos funciones globales para los tests: test y expect. Están disponibles sin 
importar nada, ya que Jest las convierte en funciones globales.

La función test se utiliza para describir un test específico y sus comprobaciones. 
Puede haber cualquier cantidad de funciones de test. El primer parámetro de esta función es 
una cadena arbitraria que debe describir el test en sí. Esta cadena se muestra en la pantalla 
durante la ejecución de los tests para facilitar la depuración.

NODE_OPTIONS=--experimental-vm-modules npx jest
 PASS  __tests__/index.test.js
  ✓ reverse (11ms) # nombre del test
El segundo parámetro es una función en la que se describe el código de comprobación. 
Ten en cuenta que este código no se ejecuta de inmediato. La función test lo agrega a Jest, 
que decide cómo y cuándo ejecutar los tests. Esto permite realizar diversas optimizaciones, 
como ejecutar los tests en paralelo.

Lo más inusual de este código son las comprobaciones. Jest utiliza "matchers" (comparadores). 
Son afirmaciones que tienen una estructura especial similar a acceder a un objeto. El principio 
general de funcionamiento de los matchers es el siguiente:

Se llama a la función expect(), a la que se le pasa el valor actual (real).
En el resultado devuelto por la función expect(), se llama al matcher adecuado, por ejemplo, 
toEqual.
El código con los matchers se parece a frases en inglés normales. Se hace así a propósito para 
que incluso las personas no programadoras puedan leerlos:

// Se espera que el resultado de la expresión reverse('hello') sea igual a 'olleh'
expect(reverse('hello')).toEqual('olleh');
Más detalles sobre los matchers en la próxima lección.

Una de las características más agradables de Jest es cómo muestra los mensajes de las 
comprobaciones fallidas. Intenta introducir un error en la función original y vuelve a 
ejecutar los tests:

 NODE_OPTIONS=--experimental-vm-modules npx jest
 FAIL  __tests__/index.test.js
  ✕ reverse (9ms)

  ● reverse

    expect(received).toEqual(expected) // Object.is equality

    Expected: "olleh"
    Received: "o|l|l|e|h"

      3 | test('reverse', () => {
      4 |   const str = 'hello';
    > 5 |   expect(reverse(str)).toEqual('olleh');
        |                        ^
      6 | })
      7 |

      at Object.toEqual (__tests__/index.test.js:5:24)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        1.683s
Ran all test suites.
En esta salida se muestran no solo el valor esperado y el valor real, sino también el 
código fuente del archivo de tests con una indicación de la comprobación específica. 
Esta es una característica increíblemente útil que acelera significativamente el análisis 
de los resultados de las pruebas y ayuda en la depuración.